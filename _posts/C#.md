---
title: C#视频学习笔记
date: 2019-05-24 12:00:00
tags: WPF
categories: 编程
---
<font face="微软雅黑"></font>
<center>C#基础知识学习</center>

<!-- more -->
<!-- TOC -->

- [1 继承](#1-继承)
    - [1 继承](#1-继承-1)
    - [2 隐藏方法](#2-隐藏方法)
    - [3 虚方法和多态](#3-虚方法和多态)
    - [4 派生类及构造函数](#4-派生类及构造函数)
    - [5 抽象类和抽象方法](#5-抽象类和抽象方法)
    - [6 密闭类](#6-密闭类)
    - [7 接口](#7-接口)
    - [8 结构和类](#8-结构和类)
- [2 静态](#2-静态)
    - [9 静态类和静态成员](#9-静态类和静态成员)
    - [10 静态类](#10-静态类)
- [3 转换和操作符重载](#3-转换和操作符重载)
    - [11 装箱和拆箱](#11-装箱和拆箱)
    - [12 自定义转换](#12-自定义转换)
    - [13 重载运算符](#13-重载运算符)
- [4 泛型](#4-泛型)
    - [14 泛型](#14-泛型)
    - [15 泛型方法](#15-泛型方法)
    - [16 约束](#16-约束)
    - [17 泛型接口](#17-泛型接口)
- [5 集合](#5-集合)
    - [18 集合](#18-集合)
- [6 委托、事件、lambda](#6-委托事件lambda)
    - [19 委托](#19-委托)
    - [20 Lambda](#20-lambda)
    - [21 事件](#21-事件)
- [总结](#总结)

<!-- /TOC -->

# 1 继承
## 1 继承
一个类派生于另一个基类，它拥有该类型的所有成员字段和函数。
class ChildClass:ParentClass{}
Object 是所有类的共同基类。

## 2 隐藏方法
不能删除基类中的任何成员，可以用与基类成员名称相同的成员来屏蔽基类成员。
隐藏数据成员：名称和类型相同的成员
屏蔽函数成员：相同函数签名
new

## 3 虚方法和多态
依赖倒置原则：程序设计要依赖抽象类
有时候需要一个容器（如数组）保存所有的基类，基类描述了共同的属性和行为。
虚方法：声明为virtual的方法就是虚方法。基类的虚方法可以在派生类中使用override进行重写。
多态：通过**指向派生类的基类引用**，调用虚函数，会根据引用所指向的派生类的实际类型，调用派生类中的同名重写函数。虚方法可以不重写。

* 重写虚方法必须有相同的可访问性，且基类方法不能为private
* 不能重写static或者非虚方法
* 方法，属性，索引器，事件，都可以声明为别团了或override

## 4 派生类及构造函数

构造函数
在执行派生类的构造函数体之前，将会隐式或者显式调用基类构造函数。实例成员初始化-基类构造函数-派生类构造函数。
base()： 显式调用基类构造函数。
this()： 调用当前类的其他构造函数。

## 5 抽象类和抽象方法
abstract  

必须是 方法、 属性、 事件、 索引。
抽象类存在只有一个目的，就是被继承。
不能实例化，不可以有实现代码块{}
可以包括抽象成员和普通成员
override：必须重写

## 6 密闭类
声明为sealed的类或方法。
密闭类：不能继承。
密闭方法：不能重写。
sealed override 的子类

## 7 接口
指定一组函数成员，而不实现他们的 引用类型。
实现多个接口：
是一种引用类型。

## 8 结构和类
* 结构是值类型(在栈中)；类是引用类型(在堆中)；
* 结构不支持继承，类支持继承
* 结构不能定义默认构造函数，编译器会定义

结构：分配内存快，作用于结束即删除，用于小型数据结构。传递过程会复制，应使用ref提高效率

# 2 静态
## 9 静态类和静态成员
static被类的所有实例共享，访问同一内存位置。
静态成员与实例成员分开保存。
直接通过类名访问。没有实例也可以访问。其初始化语句在任何静态成员使用之前调用。
静态函数也独立于任何实例，没有实例也可以调用。
静态函数不能访问实例成员，仅能访问其他静态成员。
静态构造函数：初始化静态字段，与类同名，static，无参数，无访问修饰

## 10 静态类
主要用于基础类库（如数学库）和扩展方法。
* 包含了静态的方法和属性，并且标识为static
* 不能创建实例，不能被继承
* 可以为静态类定义静态构造函数

扩展方法
* 扩展方法所属的类必须是static类
* 扩展方法本身必须是static方法
* 扩展方法第一个参数类型必须是 this—+类名
 
# 3 转换和操作符重载
## 11 装箱和拆箱

装箱：将值类型转换为引用类型，在堆上创建，语言隐式转换。将值类型进行统一操作和存储。创建了引用类型的副本，相互独立。
拆箱：将装箱后的引用类型转换为值类型，为显式转换。
 
## 12 自定义转换
为自己的结构和类进行显示和隐式的转换。使结构和类变成预期的类型，简化转换。
public static implicit/explicit operator
显式转换使用时需要用()标明。

##  13 重载运算符
利用现有某种运算符，针对自定义类或结构，定义某种运算符。
public static Class operator **()

#   4 泛型
## 14 泛型
相当于C++的模板。
传递类类型参数。
* 只有需要的实例才会被实例化
* 易于维护，修改模板则所有实例改变。

## 15 泛型方法
就是方法的模型，给定具体的类型，就可以实例化一个该操作该类型的具体方法。
## 16 约束
约束，缩小泛型类型的范围。
约束的类型：类名、class、struct；接口名；new（）

## 17 泛型接口
允许将接口成员和返回类型设置为泛型参数的接口。
interface

#  5 集合
##  18 集合
动态数组ArrayList：不安全，装箱拆箱的性能问题。
泛型List：Add、Remove、RemoveAt、clear、Count 、[index]、

字典Dictionary<Tkey,Tvalue>: 键值对，高效访问
Count、Add(,)、Remove、[key]
stack栈：先进后出。pop、push、peek
queue队列：先进先出。Dequeue、Enqueue

#  6 委托、事件、lambda
##  19 委托
持有一个或者多个方法的对象，并且可以执行和传递。
delegate
像调用函数一样使用委托类型。

## 20 Lambda
声明匿名方法
del=delegate(){...}
del=()=>{...}

## 21 事件
发布者与订阅者、事件触发和注册
可以理解为一种封装的受限制的委托。

#  总结